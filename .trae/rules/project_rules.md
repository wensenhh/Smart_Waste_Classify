## 6A 工作流项目规则

### （一）规则总览

6A 工作流是一套结构化的软件开发流程，由 **Align（对齐）、Architect（架构）、Atomize（原子化）、Approve（审批）、Automate（自动化执行）、Assess（评估）** 六个关键阶段组成。通过严格的文档驱动和自动化检查机制，确保项目从需求到交付的全过程质量可控。其核心在于将模糊需求逐步转化为可交付的代码，适用于各类软件开发项目场景（新系统开发、既有系统功能迭代等）。

### （二）各阶段详细规则

#### 1. Align（对齐阶段）



*   **目标**：将模糊需求转化为精确规范。

*   **执行步骤**：

1.  **项目上下文分析**：

*   剖析现有项目结构、技术栈、架构模式、依赖关系；

*   审查现有代码模式、文档及相关约定；

*   深入理解业务域和数据模型。

*   *示例*：基于 Python Django 框架的电商系统，需明确目录结构、Python/Django 版本、用户 / 订单 / 商品模块依赖关系等。

1.  **需求理解确认**：

*   在 `docs/任务名/` 目录下创建 `ALIGNMENT_(任务名).md`，包含：


    *   原始需求、边界确认（如 “仅实现订单支付功能，不含订单状态更新”）；

    *   需求理解（如 “支付模块与财务系统当前对接方式”）；

    *   疑问澄清（如 “支付支持的货币种类限制”）。

1.  **智能决策策略**：

*   自动识别需求歧义，生成优先级排序的结构化问题清单；

*   决策依据优先级：现有项目内容（70%）> 类似工程案例（20%）> 行业通用方案（10%）；

*   不确定问题中断流程，询问关键决策点并记录。

1.  **最终共识**：

*   生成 `docs/任务名/CONSENSUS_(任务名).md`，包含：


    *   明确的需求描述与验收标准（如 “支付成功率≥99%”）；

    *   技术实现方案、约束（如 “使用 XX 支付接口，调用频率限制”）及集成方案；

    *   任务边界限制与验收标准（解决所有不确定性）。

<!---->

*   **质量门控**：


    *   需求边界清晰无歧义；

    *   技术方案与现有架构完全对齐；

    *   验收标准具体可测试；

    *   所有关键假设已确认；

    *   项目特性规范达成一致。

#### 2. Architect（架构阶段）



*   **目标**：依据共识文档，完成系统架构设计、模块设计及接口规范制定。

*   **执行步骤**：

1.  **系统分层设计**：

*   基于 `CONSENSUS`、`ALIGNMENT` 文档，生成 `docs/任务名/DESIGN_(任务名).md`，包含：


    *   整体架构图（用 Mermaid/PlantUML 绘制，展示表现层 / 业务逻辑层 / 数据访问层等层级关系）；

    *   分层设计、核心组件说明、模块依赖关系图；

    *   接口契约定义（如 Swagger 格式的请求参数 / 返回值）；

    *   数据流向图、异常处理策略（如 “高并发导致数据库连接超时的解决方案”）。

1.  **设计原则**：

*   严格按任务范围设计，杜绝过度设计；

*   与现有系统架构保持一致，现有组件 / 模式复用率≥80%。

<!---->

*   **质量门控**：


    *   架构图清晰准确且通过可行性验证；

    *   接口定义完整覆盖所有业务场景；

    *   与现有系统无冲突；

    *   无隐性技术债务引入。

#### 3. Atomize（原子化阶段）



*   **目标**：将架构设计拆分为原子任务，明确接口和依赖关系。

*   **执行步骤**：

1.  **子任务拆分**：

*   依据 `DESIGN` 文档，在 `docs/任务名/` 目录下生成 `TASK_(任务名).md`，每个原子任务包含：


    *   输入契约（前置依赖、输入数据、环境依赖，如 “需 Python 3.8 环境，依赖 XX 数据库表结构”）；

    *   输出契约（输出数据、交付物、验收标准，如 “输出 XX 格式的支付结果报告”）；

    *   实现约束（技术栈、接口规范、质量要求，如 “用 Flask 实现接口，响应时间≤1 秒”）；

    *   依赖关系（后置任务、并行任务，如 “订单发货任务依赖支付任务完成”）。

1.  **拆分原则**：

*   每个任务实现时长≤4 小时，复杂度可控（便于高成功率交付）；

*   按功能模块分解，确保任务原子性、独立性（可独立编译 / 测试）；

*   依赖关系清晰（用 Mermaid 绘制任务依赖图），无循环依赖且关键路径明确。

<!---->

*   **质量门控**：


    *   任务覆盖完整需求；

    *   依赖关系无循环；

    *   每个任务可独立验证；

    *   复杂度评估合理。

#### 4. Approve（审批阶段）



*   **目标**：对原子任务进行人工审查，迭代修改后确定按文档执行。

*   **执行步骤**：

1.  **执行检查清单**：

*   完整性：任务计划是否覆盖所有需求；

*   一致性：是否与前期文档（Align/Architect 阶段）保持一致；

*   可行性：技术方案是否切实可行；

*   可控性：风险是否在可接受范围，复杂度是否可控；

*   可测性：验收标准是否明确可执行。

1.  **最终确认清单**：

*   明确的实现需求（无歧义）；

*   明确的子任务定义；

*   明确的边界和限制；

*   明确的验收标准；

*   清晰的代码、测试、文档质量标准。

#### 5. Automate（自动化执行）



*   **目标**：按节点执行任务，编写测试、实现代码并同步文档。

*   **执行步骤**：

1.  **逐步实施子任务**：

*   在 `docs/任务名/` 目录下创建 `ACCEPTANCE_(任务名).md`，记录任务完成情况。

1.  **代码质量要求**：

*   遵循项目现有代码规范，保持代码风格一致；

*   使用项目现有工具 / 库，复用现有组件；

*   代码精简易读，API KEY 放入 `.env` 文件且不提交至 Git。

1.  **异常处理**：

*   遇到不确定问题立即中断执行，在 `TASK` 文档中记录问题详情与位置，待人工澄清后继续。

1.  **逐步实施流程**：

*   按任务依赖顺序执行，每个子任务需完成：


    *   执行前检查（验证输入契约、环境准备、依赖满足）；

    *   实现核心逻辑（按设计文档编写代码）；

    *   编写单元测试（覆盖边界条件、异常情况）；

    *   运行验证测试、更新相关文档；

    *   完成后立即验证。

#### 6. Assess（评估阶段）



*   **目标**：对执行结果进行质量评估，更新文档并确认交付。

*   **执行步骤**：

1.  **验证执行结果**：

*   更新 `docs/任务名/ACCEPTANCE_(任务名).md`，进行整体验收检查：


    *   所有需求已实现，验收标准全部满足；

    *   项目编译通过，所有测试通过；

    *   功能完整性验证通过，实现与设计文档一致。

1.  **质量评估指标**：

*   代码质量（规范、可读性、复杂度）；

*   测试质量（覆盖率、用例有效性）；

*   文档质量（完整性、准确性、一致性）；

*   现有系统集成效果；

*   无新增技术债务。

1.  **最终交付物**：

*   `docs/任务名/FINAL_(任务名).md`：项目总结报告（经验教训、成果等）；

*   `docs/任务名/TODO_(任务名).md`：待办事宜、缺失配置等（精简明确）。

1.  **TODO 询问**：向用户确认 `TODO` 解决方式，提供操作指引。